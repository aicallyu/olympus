# ADR-002: Unbrowse — API-Speed Web Access for OLYMPUS Agents

**Status:** Accepted (Deferred Implementation)  
**Date:** 2026-02-05  
**Author:** Juan (System Architect), Claude (Co-Architect)  
**Applies to:** All OLYMPUS agents with external web interaction needs  
**Dependencies:** OpenClaw runtime (already deployed)

---

## Context

OLYMPUS agents currently operate in a closed ecosystem: they communicate via Supabase (REST API), execute tasks on the local filesystem, and report through WhatsApp. No agent currently needs to interact with external websites.

**This will change.**

As the system matures, agents will need to interact with external services that don't have official APIs or MCP servers — deployment platforms, monitoring dashboards, third-party tools, data sources, and SaaS products.

The default approach for agent web interaction is browser automation (Playwright, Puppeteer, Selenium). This approach is **slow** (10-45 seconds per action), **unreliable** (15-30% failure rate), and **resource-heavy** (500MB+ RAM per headless Chrome instance).

**Unbrowse** is an OpenClaw plugin that eliminates browser automation by capturing a website's internal API calls and converting them into direct, reusable agent skills. Since OLYMPUS already runs on OpenClaw, Unbrowse is a native capability — one plugin install away.

---

## Decision

OLYMPUS will adopt **Unbrowse** as the standard method for external web interaction when the need arises. Browser automation will only be used for the initial capture session. All subsequent interactions will use direct API calls generated by Unbrowse.

**Implementation is deferred** until the first concrete use case emerges where an agent needs to interact with an external website.

---

## How Unbrowse Works

### The Problem It Solves

Every modern website is a frontend layer on top of API calls. When a React app loads a dashboard, it calls `GET /api/metrics`. When a user clicks "Deploy", the button sends `POST /api/deployments`. The browser is just a rendering layer — a GUI costume on top of HTTP requests.

Browser automation forces agents to interact with the **costume** instead of the **API underneath**. This means:

1. Launch a headless browser (5 seconds, 500MB RAM)
2. Navigate to the page (3 seconds)
3. Wait for JavaScript to render (2 seconds)
4. Find DOM elements (1 second)
5. Read or click (1 second)
6. Hope nothing changed in the DOM since last time (15-30% failure rate)

The actual data exchange that happened during all of that? **A single HTTP request that took 200 milliseconds.**

### The Unbrowse Approach

Unbrowse works in three phases:

#### Phase 1 — Capture
An agent (or human) browses a website once. During this session, Unbrowse intercepts all network traffic via Chrome DevTools Protocol. Every XHR request, fetch call, WebSocket message, authentication header, and cookie is recorded. The agent doesn't need to do anything special — just use the site normally.

#### Phase 2 — Extract
The captured network traffic is analyzed automatically:
- Real API endpoints are identified and separated from analytics, tracking, and noise
- Authentication methods are detected — Bearer tokens, session cookies, API keys, OAuth flows
- Request parameters are inferred from captured payloads
- Endpoints are clustered by resource type (e.g., all user-related endpoints grouped together)
- Response schemas are mapped from observed JSON structures

#### Phase 3 — Generate
A complete API skill package is produced:
- Documented endpoint catalog with request/response schemas
- TypeScript client with typed methods for each endpoint
- Authentication configuration with token refresh logic
- Error handling patterns observed from the site's actual error responses

This skill package becomes a **permanent, reusable tool** that any OpenClaw agent can install and use. No browser needed again for that website.

---

## Performance Comparison

| Metric | Browser Automation | Unbrowse (Direct API) |
|--------|-------------------|----------------------|
| **Speed per action** | 10-45 seconds | 100-300 milliseconds |
| **Reliability** | 70-85% | 95%+ |
| **RAM usage** | 500MB+ (headless Chrome) | ~0 (HTTP calls) |
| **Data format** | Scraped DOM text (fragile) | Clean JSON (structured) |
| **Action types** | Click, type, wait, scrape | Direct API calls (GET, POST, PUT, DELETE) |
| **Maintenance** | Breaks when DOM changes | Stable until API changes |
| **Concurrent operations** | Limited by browser instances | Limited only by rate limits |

---

## The Compound Effect

Every API that Unbrowse captures becomes a "skill" — a reusable package any OpenClaw agent can install. This creates a compound effect:

- **PROMETHEUS** captures the Vercel deployment API once
  - Now ATLAS, HERCULOS, and ATHENA can all trigger deployments and check build status at API speed
  
- **ARGOS** captures a project management tool's API
  - Now any agent can create tickets, update status, and pull reports without human intervention

**One agent learns. All agents benefit. The system gets faster with every new external interaction.**

---

## OLYMPUS Integration Architecture

### Where Unbrowse Fits

```
┌─────────────────────────────────────────────────────┐
│                    OLYMPUS                          │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐             │
│  │  ARGOS  │  │  ATLAS  │  │HERCULOS │  ...agents  │
│  └────┬────┘  └────┬────┘  └────┬────┘             │
│       │            │            │                   │
│       ▼            ▼            ▼                   │
│  ┌─────────────────────────────────────┐            │
│  │        OpenClaw Runtime             │            │
│  │  ┌──────────────────────────────┐   │            │
│  │  │      Unbrowse Plugin         │   │            │
│  │  │  ┌────────────────────────┐  │   │            │
│  │  │  │  Captured API Skills   │  │   │            │
│  │  │  │  • vercel-api.skill    │  │   │            │
│  │  │  │  • github-api.skill    │  │   │            │
│  │  │  │  • railway-api.skill   │  │   │            │
│  │  │  │  • sentry-api.skill    │  │   │            │
│  │  │  │  • notion-api.skill    │  │   │            │
│  │  │  └────────────────────────┘  │   │            │
│  │  └──────────────────────────────┘   │            │
│  └─────────────────────────────────────┘            │
│       │            │            │                   │
│       ▼            ▼            ▼                   │
│  ┌─────────────────────────────────────┐            │
│  │      External Services              │            │
│  │  Vercel · GitHub · Railway · Sentry │            │
│  │  Notion · Slack · Any website       │            │
│  └─────────────────────────────────────┘            │
└─────────────────────────────────────────────────────┘
```

---

## Implementation Plan

### Phase 1: Defer (Current)
- No immediate need for external web interaction
- Agents work within Supabase + local filesystem ecosystem
- Monitor for first concrete use case

### Phase 2: First Capture (When Needed)
- Identify website that needs interaction
- Human performs capture session (or agent with human supervision)
- Unbrowse generates skill package
- Store skill in `/skills/unbrowse/[service-name]/`

### Phase 3: Distribution
- Install skill in OpenClaw runtime
- All agents can now use direct API calls
- Document usage in agent WORKING.md files

---

## When to Implement

**Trigger:** First agent task that requires external web interaction and no official API/MCP exists.

**Examples:**
- PROMETHEUS needs to trigger deployment on platform without CLI/MCP
- ATHENA needs to pull test results from dashboard without API
- HERMES needs to update documentation site without API access

---

## Success Criteria

- [ ] First Unbrowse skill captured and tested
- [ ] Agents using direct API calls instead of browser automation
- [ ] Documented speed improvement (10x+ faster than browser)
- [ ] Skill library growing with each new external service

---

## References

- OpenClaw Unbrowse Plugin Documentation
- OpenClaw Runtime Architecture
